<%inherit file="base.html"/>

<%block name="bodycontent">
    <p class="title">0-scope</p>
    
    <p>Based on a circuit from <a title="here" href="http://yveslebrac.blogspot.com/" target="_blank">here</a>, 0-Scope is an attempt at making a low cost, cross platform oscilliscope for debugging circuits. As of right now, it's not quite as fast or featureful as I would like, but I'd better write it up now or I never will.</p>

    <p class="image"><a href="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/finished_out.png"><img class="size-medium wp-image-43" title="finished_out" src="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/finished_out.png" alt="The finished board." width="300" height="225" /></a></p>

    <p>I designed the board in EagleCad. It is single layer, so you can make it at home. It is meant to be milled or etched on <a title="FR-4" href="http://en.wikipedia.org/wiki/FR-4" target="_blank">FR-4</a>, with a little thickness added (however you see fit).</p>

    <p class="image"><a href="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/milling_out.png"><img class="size-medium wp-image-44" title="milling_out" src="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/milling_out.png" alt="Milling the board on the modela." width="300" height="225" /></a></p>

    <p class="image"><a href="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/soldering_out.png"><img class="size-medium wp-image-45" title="soldering_out" src="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/soldering_out.png" alt="Populating the board." width="300" height="225" /></a></p>

    <p>It fits right into a USB A port, so you don't need any expensive connectors or cables.

    <p class="image"><a href="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/poscope_hardware.zip">0-scope_hardware</a></p>

    <p>The firmware is written using the *excellent* avr-usb libraries. All the relevant code is in C. The microcontroller runs on a PLL internal oscillator, at ~16.5MHz, and poses as a USB HID device. The scope data for each channel is relayed over HID reports. Everything is open source.</p>

    <p class="image"><a href="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/poscope_firmware.zip">0-scope_firmware</a></p>

    <p>Software is written in C and python. I used the libusb and libhid libraries (both cross platform), with a libhid python interface generated by swig. This let's me grab the data from the scope in a python app. Unfortunately it must be run with root privileges. (use sudo!)</p>

    <p class="image"><a href="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/scope.png"><img class="size-medium wp-image-51 aligncenter" title="scope" src="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/scope.png" alt="" width="300" height="244" /></a></p>

    <p>To graph it, I used matplotlib and made two moving subplots. The software at this point is very basic, and needs a bit of work to really get full 'oscilliscope-level' functionality. But you can quickly and easily visualize waveforms.</p>

    <p class="image"><a href="http://lightworks.mit.edu/blag/wp-content/uploads/2008/10/poscope_software.zip">0-scope_software</a></p>
    
    <p>This was a really fun little toy to build, and it kept me busy for about a week. Maybe by alternating between ADC's or overclocking a faster AVR with a higher ADC sample rate, better performance could be achieved. Even on the tiny45, by doing some software tricks, it should be possible to sacrifice the 10bit ADC performance for 8bits + a faster speed. I would also like add some features to the software to change the time scale, measure signals, and trigger off of one probe. It would also be useful to save plots, and set certain features in the firmware (8 or 10 bit, etc).</p>
    
</%block>